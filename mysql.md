## 存储引擎

MySQL默认的存储引擎是MyISAM，其他常用的就是InnoDB了。

具体区别如下：

|  | MyISAM | InnoDB |
| :--- | :--- | :--- |
| 存储结构 | 每张表被存放在三个文件：frm-表格定义MYD\(MYData\)-数据文件MYI\(MYIndex\)-索引文件 | 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB |
| 存储空间 | MyISAM可被压缩，存储空间较小 | InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 |
| 可移植性、备份及恢复 | 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 | 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 |
| 事务安全 | 不支持 每次查询具有原子性 | 支持 具有事务\(commit\)、回滚\(rollback\)和崩溃修复能力\(crash recovery capabilities\)的事务安全\(transaction-safe \(ACID compliant\)\)型表 |
| AUTO\_INCREMENT | MyISAM表可以和其他字段一起建立联合索引 | InnoDB中必须包含只有该字段的索引 |
| SELECT | MyISAM更优 |  |
| INSERT |  | InnoDB更优 |
| UPDATE |  | InnoDB更优 |
| DELETE |  | InnoDB更优 它不会重新建立表，而是一行一行的删除 |
| COUNT without WHERE | MyISAM更优。因为MyISAM保存了表的具体行数 | InnoDB没有保存表的具体行数，需要逐行扫描统计，就很慢了 |
| COUNT with WHERE | 一样 | 一样，InnoDB也会锁表 |
| 锁 | 只支持表锁 | 支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的 |
| 外键 | 不支持 | 支持 |
| FULLTEXT全文索引 | 支持 | 不支持 可以通过使用Sphinx从InnoDB中获得全文索引，会慢一点 |

  


[MySQL存储引擎MyISAM与InnoDB的优劣](https://www.pureweber.com/article/myisam-vs-innodb/)

## 锁

对于InnoDB表，主要有以下几点

* （１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。
* （２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。
* （３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。
* （４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。
* （５）锁冲突甚至死锁很难完全避免。

  在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：

  * 尽量使用较低的隔离级别
  * 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。
  * 选择合理的事务大小，小事务发生锁冲突的几率也更小。
  * 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。
  * 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。
  * 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。
  * 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。
  * 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。

[更多内容请查看](http://www.cnblogs.com/chenqionghe/p/4845693.html)

