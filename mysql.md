# 存储引擎

MySQL默认的存储引擎是MyISAM，其他常用的就是InnoDB了。

具体区别如下：

|  | MyISAM | InnoDB |
| :--- | :--- | :--- |
| 存储结构 | 每张表被存放在三个文件：frm-表格定义MYD\(MYData\)-数据文件MYI\(MYIndex\)-索引文件 | 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB |
| 存储空间 | MyISAM可被压缩，存储空间较小 | InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 |
| 可移植性、备份及恢复 | 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 | 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 |
| 事务安全 | 不支持 每次查询具有原子性 | 支持 具有事务\(commit\)、回滚\(rollback\)和崩溃修复能力\(crash recovery capabilities\)的事务安全\(transaction-safe \(ACID compliant\)\)型表 |
| AUTO\_INCREMENT | MyISAM表可以和其他字段一起建立联合索引 | InnoDB中必须包含只有该字段的索引 |
| SELECT | MyISAM更优 |  |
| INSERT |  | InnoDB更优 |
| UPDATE |  | InnoDB更优 |
| DELETE |  | InnoDB更优 它不会重新建立表，而是一行一行的删除 |
| COUNT without WHERE | MyISAM更优。因为MyISAM保存了表的具体行数 | InnoDB没有保存表的具体行数，需要逐行扫描统计，就很慢了 |
| COUNT with WHERE | 一样 | 一样，InnoDB也会锁表 |
| 锁 | 只支持表锁 | 支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的 |
| 外键 | 不支持 | 支持 |
| FULLTEXT全文索引 | 支持 | 不支持 可以通过使用Sphinx从InnoDB中获得全文索引，会慢一点 |

资料来源：

[MySQL存储引擎MyISAM与InnoDB的优劣](https://www.pureweber.com/article/myisam-vs-innodb/)

# 锁

对于InnoDB表，主要有以下几点

* （１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。
* （２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。
* （３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。
* （４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。
* （５）锁冲突甚至死锁很难完全避免。

  在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：

  * 尽量使用较低的隔离级别
  * 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。
  * 选择合理的事务大小，小事务发生锁冲突的几率也更小。
  * 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。
  * 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。
  * 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。
  * 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。
  * 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。

[更多内容请查看](http://www.cnblogs.com/chenqionghe/p/4845693.html)

# 索引

索引的目的是为了提高查询效率。原理和图书的目录类似。

## 索引的类型

索引是在MYSQL的存储引擎层中实现的，而不是在服务层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。MYSQL目前提供了一下4种索引。

* B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。
* HASH 索引：只有Memory引擎支持，使用场景简单。
* R-Tree 索引\(空间索引\)：空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。
* Full-text \(全文索引\)：全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。

**MyISAM、InnoDB引擎、Memory三个常用引擎类型比较**

| 索引 | MyISAM引擎 | InnoDB引擎 | Memory引擎 |
| :--- | :--- | :--- | :--- |
| B-Tree 索引 | 支持 | 支持 | 支持 |
| HASH 索引 | 不支持 | 不支持 | 支持 |
| R-Tree 索引 | 支持 | 不支持 | 不支持 |
| Full-text 索引 | 不支持 | 暂不支持 | 不支持 |

## B-Tree 索引

![](/media/image/import.png)

非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

## 聚簇索引

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

[MYSQL索引：对聚簇索引和非聚簇索引的认识](https://blog.csdn.net/alexdamiao/article/details/51934917)

## 建索引的几大原则 {#-}

1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询\(&gt;、&lt;、between、like\)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立\(a,b,c,d\)顺序的索引，d是用不到索引的，如果建立\(a,b,d,c\)的索引则都可以用到，a,b,d的顺序可以任意调整。  
2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立\(a,b,c\)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式  
3.尽量选择区分度高的列作为索引,区分度的公式是count\(distinct col\)/count\(\*\)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录  
4.索引列不能参与计算，保持列“干净”，比如from\_unixtime\(create\_time\) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create\_time = unix\_timestamp\(’2014-05-29’\);  
5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加\(a,b\)的索引，那么只需要修改原来的索引即可。

## 参考资料

[MYSQL-索引](https://segmentfault.com/a/1190000003072424)

[MySQL索引原理及慢查询优化](https://tech.meituan.com/mysql-index.html)

