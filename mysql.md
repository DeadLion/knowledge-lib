# 存储引擎

MySQL默认的存储引擎是MyISAM，其他常用的就是InnoDB了。

具体区别如下：

|  | MyISAM | InnoDB |
| :--- | :--- | :--- |
| 存储结构 | 每张表被存放在三个文件：frm-表格定义MYD\(MYData\)-数据文件MYI\(MYIndex\)-索引文件 | 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB |
| 存储空间 | MyISAM可被压缩，存储空间较小 | InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 |
| 可移植性、备份及恢复 | 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 | 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 |
| 事务安全 | 不支持 每次查询具有原子性 | 支持 具有事务\(commit\)、回滚\(rollback\)和崩溃修复能力\(crash recovery capabilities\)的事务安全\(transaction-safe \(ACID compliant\)\)型表 |
| AUTO\_INCREMENT | MyISAM表可以和其他字段一起建立联合索引 | InnoDB中必须包含只有该字段的索引 |
| SELECT | MyISAM更优 |  |
| INSERT |  | InnoDB更优 |
| UPDATE |  | InnoDB更优 |
| DELETE |  | InnoDB更优 它不会重新建立表，而是一行一行的删除 |
| COUNT without WHERE | MyISAM更优。因为MyISAM保存了表的具体行数 | InnoDB没有保存表的具体行数，需要逐行扫描统计，就很慢了 |
| COUNT with WHERE | 一样 | 一样，InnoDB也会锁表 |
| 锁 | 只支持表锁 | 支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的 |
| 外键 | 不支持 | 支持 |
| FULLTEXT全文索引 | 支持 | 不支持 可以通过使用Sphinx从InnoDB中获得全文索引，会慢一点 |

资料来源：

[MySQL存储引擎MyISAM与InnoDB的优劣](https://www.pureweber.com/article/myisam-vs-innodb/)

# 锁

对于InnoDB表，主要有以下几点

* （１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。
* （２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。
* （３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。
* （４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。
* （５）锁冲突甚至死锁很难完全避免。

  在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：

  * 尽量使用较低的隔离级别
  * 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。
  * 选择合理的事务大小，小事务发生锁冲突的几率也更小。
  * 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。
  * 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。
  * 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。
  * 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。
  * 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。

[更多内容请查看](http://www.cnblogs.com/chenqionghe/p/4845693.html)

# 索引

索引的目的是为了提高查询效率。原理和图书的目录类似。

## 索引的类型

索引是在MYSQL的存储引擎层中实现的，而不是在服务层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。MYSQL目前提供了一下4种索引。

* B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。
* HASH 索引：只有Memory引擎支持，使用场景简单。
* R-Tree 索引\(空间索引\)：空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。
* Full-text \(全文索引\)：全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。

**MyISAM、InnoDB引擎、Memory三个常用引擎类型比较**

| 索引 | MyISAM引擎 | InnoDB引擎 | Memory引擎 |
| :--- | :--- | :--- | :--- |
| B-Tree 索引 | 支持 | 支持 | 支持 |
| HASH 索引 | 不支持 | 不支持 | 支持 |
| R-Tree 索引 | 支持 | 不支持 | 不支持 |
| Full-text 索引 | 不支持 | 暂不支持 | 不支持 |

## B-Tree 索引

![](/media/image/import.png)

非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

## 聚簇索引

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

[MYSQL索引：对聚簇索引和非聚簇索引的认识](https://blog.csdn.net/alexdamiao/article/details/51934917)

## 建索引的几大原则 {#-}

1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询\(&gt;、&lt;、between、like\)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立\(a,b,c,d\)顺序的索引，d是用不到索引的，如果建立\(a,b,d,c\)的索引则都可以用到，a,b,d的顺序可以任意调整。  
2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立\(a,b,c\)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式  
3.尽量选择区分度高的列作为索引,区分度的公式是count\(distinct col\)/count\(\*\)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录  
4.索引列不能参与计算，保持列“干净”，比如from\_unixtime\(create\_time\) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create\_time = unix\_timestamp\(’2014-05-29’\);  
5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加\(a,b\)的索引，那么只需要修改原来的索引即可。

## 参考资料

[MYSQL-索引](https://segmentfault.com/a/1190000003072424)

[MySQL索引原理及慢查询优化](https://tech.meituan.com/mysql-index.html)



# 数据库事务

事务是数据库管理系统数据库执行过程中的一个逻辑单位，由一个有限的操作序列构成。

## 四大特性（ACID）

* 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

* 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
* 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
* 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



## 四种隔离级别

| 隔离级别 | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| :--- | :--- | :--- | :--- |
| 未提交读（Read uncommitted） | 可能 | 可能 | 可能 |
| 已提交读（Read committed） | 不可能 | 可能 | 可能 |
| 可重复读（Repeatable read） | 不可能 | 不可能 | 可能 |
| 可串行化（Serializable ） | 不可能 | 不可能 | 不可能 |

* 未提交读\(Read Uncommitted\)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
* 提交读\(Read Committed\)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 \(不重复读\)
* 可重复读\(Repeated Read\)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
* 串行读\(Serializable\)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

Read Uncommitted这种级别，数据库一般都不会用，而且任何操作都不会加锁。

InnoDB默认为可重复读

[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/innodb-lock.html)

  




